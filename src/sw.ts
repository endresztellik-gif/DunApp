/**
 * DunApp PWA - Custom Service Worker
 *
 * Handles:
 * - Push notifications for water level alerts
 * - Offline caching with Workbox
 * - Background sync
 *
 * Created: 2025-11-03 (Phase 4.6e)
 */

/// <reference lib="webworker" />
/// <reference types="vite/client" />

import { clientsClaim } from 'workbox-core';
import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';

declare const self: ServiceWorkerGlobalScope;

// Claim clients immediately
clientsClaim();

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by Vite
precacheAndRoute(self.__WB_MANIFEST);

/**
 * Push Notification Event Handler
 *
 * Triggered when a push message is received from the server.
 * Displays a notification to the user with custom data.
 */
self.addEventListener('push', (event: PushEvent) => {
  console.log('[Service Worker] Push received:', event);

  // Default notification data
  const defaultData = {
    title: 'DunApp Értesítés',
    body: 'Új üzenet érkezett.',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    tag: 'dunapp-notification',
    data: {},
  };

  let notificationData = defaultData;

  // Parse push payload if available
  if (event.data) {
    try {
      notificationData = { ...defaultData, ...event.data.json() };
    } catch (error) {
      console.error('[Service Worker] Failed to parse push data:', error);
    }
  }

  // Show notification
  const promiseChain = self.registration.showNotification(notificationData.title, {
    body: notificationData.body,
    icon: notificationData.icon,
    badge: notificationData.badge,
    tag: notificationData.tag,
    data: notificationData.data,
    vibrate: [200, 100, 200],
    requireInteraction: true,
    actions: [
      {
        action: 'open',
        title: 'Megnyitás',
      },
      {
        action: 'close',
        title: 'Bezárás',
      },
    ],
  });

  event.waitUntil(promiseChain);
});

/**
 * Notification Click Event Handler
 *
 * Triggered when user clicks on a notification.
 * Opens the app at the relevant URL or focuses an existing window.
 */
self.addEventListener('notificationclick', (event: NotificationEvent) => {
  console.log('[Service Worker] Notification click:', event);

  const notification = event.notification;
  const action = event.action;

  notification.close();

  if (action === 'close') {
    // User clicked "Bezárás" - do nothing
    return;
  }

  // Determine target URL
  let targetUrl = '/';
  if (notification.data && notification.data.url) {
    targetUrl = notification.data.url;
  } else if (notification.data && notification.data.station === 'Mohács') {
    targetUrl = '/?module=water-level';
  }

  // Open app at target URL or focus existing window
  const promiseChain = self.clients
    .matchAll({
      type: 'window',
      includeUncontrolled: true,
    })
    .then((clientList) => {
      // Check if app is already open
      for (const client of clientList) {
        if (client.url.includes(self.location.origin) && 'focus' in client) {
          return client.focus();
        }
      }

      // Open new window if app is not open
      if (self.clients.openWindow) {
        return self.clients.openWindow(targetUrl);
      }
    });

  event.waitUntil(promiseChain);
});

/**
 * Push Subscription Change Event Handler
 *
 * Triggered when push subscription is updated or lost.
 * Attempts to resubscribe the user.
 */
self.addEventListener('pushsubscriptionchange', (event: PushSubscriptionChangeEvent) => {
  console.log('[Service Worker] Push subscription changed:', event);

  const promiseChain = self.registration.pushManager
    .subscribe({
      userVisibleOnly: true,
      applicationServerKey: self.registration.pushManager.getSubscription().then((subscription) => {
        if (subscription) {
          const rawKey = subscription.options.applicationServerKey;
          return rawKey;
        }
        // Fallback: get VAPID key from environment (injected during build)
        return import.meta.env.VITE_VAPID_PUBLIC_KEY;
      }),
    })
    .then((newSubscription) => {
      console.log('[Service Worker] Resubscribed:', newSubscription);

      // Send new subscription to backend
      // This would typically POST to /api/push-subscriptions endpoint
      // For now, we'll rely on the frontend to handle resubscription
    })
    .catch((error) => {
      console.error('[Service Worker] Resubscription failed:', error);
    });

  event.waitUntil(promiseChain);
});

console.log('[Service Worker] Loaded and ready for push notifications!');
